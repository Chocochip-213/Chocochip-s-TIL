# **스택과 재귀 호출 핵심 정리**

## **1\. 스택 (Stack)**

스택은 데이터를 임시로 저장하는 선형 자료구조로, **후입선출(LIFO, Last-In, First-Out)** 원칙에 따라 동작합니다. 가장 나중에 들어온 데이터가 가장 먼저 나가는 구조로, 마치 접시를 쌓고 위에서부터 다시 꺼내는 것과 같습니다.

### **주요 특징 및 연산**

* **후입선출 (LIFO)**: "가장 나중에 들어온 것이 가장 먼저 나간다"는 핵심 원칙입니다.  
* **탑 포인터 (Top Pointer)**: 항상 스택의 가장 위, 즉 마지막에 추가된 데이터를 가리킵니다. 이 덕분에 데이터 추가 및 삭제가 O(1)의 시간 복잡도로 매우 빠릅니다.  
* **주요 연산**  
  * **Push**: 스택의 가장 위에 새로운 데이터를 추가합니다. (데이터 추가 전, 스택이 가득 찼는지 확인이 필요할 수 있습니다.)  
  * **Pop**: 스택의 가장 위에서 데이터를 꺼냅니다. (데이터를 꺼내기 전, 스택이 비어있는지 확인해야 합니다.)

## **2\. 스택의 활용**

### **2.1. 괄호 검사**

올바른 괄호 ( ), { }, \[ \]의 쌍을 검사하는 데 스택이 효과적으로 사용됩니다.

* **로직**:  
  1. **여는 괄호** (, {, \[ 를 만나면: 스택에 **Push** 합니다.  
  2. **닫는 괄호** ), }, \] 를 만나면: 스택에서 **Pop** 하여 짝이 맞는지 확인합니다.  
* **오류 조건**:  
  * 닫는 괄호를 만났을 때 스택이 비어있는 경우 (짝이 될 여는 괄호가 없음).  
  * Pop한 괄호와 현재 닫는 괄호의 짝이 맞지 않는 경우.  
  * 모든 문자열을 확인한 후에도 스택에 여는 괄호가 남아있는 경우.

### **2.2. 계산기 구현 (중위 표기법 → 후위 표기법)**

사람이 사용하는 A \+ B (중위 표기법)를 컴퓨터가 계산하기 쉬운 A B \+ (후위 표기법)으로 변환하고, 그 결과를 계산하는 과정에 스택이 핵심적으로 사용됩니다.

#### **1단계: 중위 표기법 → 후위 표기법 변환**

연산자 우선순위를 처리하기 위해 스택을 사용합니다.

* **피연산자 (숫자)**: 즉시 출력합니다.  
* **여는 괄호 (**: 무조건 스택에 **Push** 합니다.  
* **닫는 괄호 )**: 스택에서 **여는 괄호 (를 만날 때까지** 모든 연산자를 **Pop**하여 출력합니다. 여는 괄호는 출력하지 않고 버립니다.  
* **연산자 \+, \-, \*, /**:  
  * 스택의 맨 위(top)에 있는 연산자의 우선순위가 **현재 연산자보다 높거나 같으면**, 해당 연산자를 **Pop**하여 출력합니다. 이 과정을 계속 반복합니다.  
  * 위 조건이 끝나면, 현재 연산자를 스택에 **Push** 합니다.  
* **마지막**: 모든 수식을 처리한 후, 스택에 남아있는 모든 연산자를 **Pop**하여 출력합니다.

#### **2단계: 후위 표기법 계산**

후위 표기법은 이미 연산 순서가 정해져 있어 계산이 간단합니다.

1. **피연산자 (숫자)**: 스택에 **Push** 합니다.  
2. **연산자**: 스택에서 피연산자 **두 개를 Pop**하여 계산한 후, 그 결과를 다시 스택에 **Push** 합니다.  
3. **최종 결과**: 모든 수식 처리가 끝나면 스택에 단 하나의 값이 남게 되며, 이 값이 최종 결과입니다.

## **3\. 재귀 호출 (Recursion)**

재귀 호출은 함수가 **자기 자신을 다시 호출**하는 프로그래밍 기법입니다. 문제를 동일한 구조의 더 작은 문제로 나누어 해결하는 방식입니다.

### **핵심 구성 요소**

1. **종료 조건 (Base Case)**: 재귀 호출이 멈추는 조건입니다. 이 조건이 없으면 함수가 무한히 호출되어 **스택 오버플로우(Stack Overflow)** 오류가 발생합니다.  
2. **유도 부분 (Inductive Part)**: 문제를 더 작은 단위로 쪼개어 자기 자신을 호출하는 부분입니다.

### **재귀 호출 예시**

* **팩토리얼 (Factorial)**  
  * n\! \= n \* (n-1)\!  
  * **종료 조건**: n \= 0 또는 n \= 1일 때 1을 반환합니다.  
* **피보나치 수열 (Fibonacci)**  
  * F(n) \= F(n-1) \+ F(n-2)  
  * **종료 조건**: n \= 0일 때 0, n \= 1일 때 1을 반환합니다.  
* **거듭제곱 (Power)**  
  * x^n \= x \* x^(n-1)  
  * **종료 조건**: n \= 0일 때 1을 반환합니다.  
  * **성능 개선 (분할 정복)**: n을 절반으로 나누어 계산하면(x^n \= x^(n/2) \* x^(n/2)) 호출 횟수를 크게 줄여 성능을 향상시킬 수 있습니다.

## **4\. 함께 알아두면 좋은 개념**

### **값 전달 (Pass by Value) vs. 참조 전달 (Pass by Reference)**

함수에 인자를 전달할 때, 데이터 타입에 따라 동작 방식이 달라져 주의가 필요합니다.

* **불변(Immutable) 객체** (예: 숫자, 문자열): **값만 복사**되어 전달됩니다. 함수 안에서 값을 변경해도 원본 데이터는 변하지 않습니다. (값 전달)  
* **가변(Mutable) 객체** (예: 리스트, 딕셔너리): 객체의 **메모리 주소가 복사**되어 전달됩니다. 함수 안에서 값을 변경하면 **원본 데이터도 함께 변경**됩니다. (참조 전달)
